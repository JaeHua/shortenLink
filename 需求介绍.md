# 短链系统设计方案

## 需求背景

公司内部业务需要发送大量的营销短信、通知类短信，需要一个短链接服务满足各业务线的使用：
- 提供转链接口
- 后续支持提供点击的统计数据报表

## 需求描述

1. 输入一个长网址得到一个唯一的短网址
2. 用户点击短网址能够正常跳转到对应的网址
3. 为了保证业务的延续性，短网址长期有效

## 需求分析

### 产品定位

1. 公司内部业务使用的短网址服务，只接收公司内部的长链转短链需求（不对外提供短链功能）
2. 基本在国内使用（点击链接的用户绝大多数为国内用户）
3. 后续可能会要求提供短链的访问数据报表

### 规模

1. 大致服务于公司内部x条业务线
2. 大致服务的用户规模有x亿
3. xx QPS

### 技术指标

1. 延时xms内
2. 可靠性99.99%
3. 安全性

## 需求实现流程

需求预沟通 → 需求评审 → 技术评审 → 排期开发 → 联调 → 测试 → 上线（小流量 → 全流量）

## 需求拆解

根据需求分析，可以将需求拆分为转链模块、存储和访问链接模块。

### 转链模块

1. 相同的长链要转为同一个短链
2. 生成的短链为尽量短的字符（如：qlmi.cn/p6Yo7z）

**引申需求点或注意事项：**
1. 需要避免某些不合适的词（例如f**k、stupid）和某些特殊含义的词（version、health等）
2. 避免循环转链（把已经是短链的再拿来转短链）

### 存储

1. 保存原始长链接与短链接的对应关系
2. 能够根据短链接查找到原始的长链接

### 查看链接模块

1. 根据短链查询到长链后返回重定向响应
2. 后续数据报表需求可能需要采集并统计请求头数据

## 系统设计

### 总体设计方案

通过分析可以得知，这是一个典型的读多写少的系统。

进一步分析这个短链系统区别于其他读多写少的业务场景，它的特点是数据写入后基本不会改变（好处是不需要考虑数据一致性的问题，可以放心大胆的使用缓存系统来提高读的效率）。

### 短链生成方式

关于生成短链有以下几种方案：

#### Hash方案

使用hash函数对长链接进行hash，得到hash值作为短链标识符。

- **优势**：简单
- **缺点**：数据量大之后，会出现哈希冲突

**MurmurHash**是一种非加密型哈希函数，和其它流行哈希函数相比，对于规律性较强的key随机分布特性表现更良好，在很多开源的软件项目（Redis，Memcached，Cassandra，HBase，Lucene都用它）都有使用。有以下几个特性：
- 随机分布特性表现好
- 算法速度快

#### 发号器/自增序列方案

每收到一个转链请求，就使用发号器生成递增（1、2、3、4...以此递增）的序号，然后将该序号转为62进制，最后拼接到短域名后即得到最终的短链。

**发号器方案的优劣如下：**

- **优势**：
  - 生成的id递增
  - 理论上容量足够满足现实需求

- **缺点**：
  - 高并发下的发号器设计是难点

### 发号器实现方式

常见的发号器实现方式有以下几种：

1. **基于UUID实现**
   - 优势：不会重复、性能好
   - 劣势：数字太大了，32位16进制数

2. **基于Redis实现发号器**
   - 优势：高性能
   - 劣势：需搭建高可用架构并考虑持久化

3. **基于雪花算法的分布式ID生成器**
   - 优势：高性能、高可用
   - 劣势：实现复杂，依赖时钟

4. **基于MySQL自增主键的发号器**
   - 优势：简单、可靠
   - 劣势：依赖MySQL，性能会成为瓶颈，但可通过分片扩展可用性

### 基于MySQL主键实现发号器

这里采用的是基于MySQL数据库主键做发号器的方案。

我们新建一个数据表，这个表没有其他数据字段，只有一个主键。每有一次转链请求，我们都在这个数据库中插入一个新行，那么我们可以使用该表的自增ID作为生成的号码。

**MySQL REPLACE**

REPLACE的工作方式与INSERT完全相同，只是如果表中的旧行与新行在PRIMARY KEY或UNIQUE索引具有相同的值，则在插入新行之前删除旧行。

这就让我们能够在数据库中的单行位置进行自动更新，并获得一个新的自动递增的主ID。

### 分片部署

为了避免单点故障，我们将我们的ID生成器分成奇数和偶数两部分，分别部署在两个MySQL服务器。

两个数据表配置不同的auto-increment-offset，server1生成1、3、5、7、9...，server2生成2、4、6、8...

### 数据表

存储长-短链接映射的数据表：

```sql
CREATE TABLE short_url_map (
    id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '主键',
    create_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    create_by VARCHAR(64) NOT NULL DEFAULT '' COMMENT '创建者',
    is_del tinyint UNSIGNED NOT NULL DEFAULT '0' COMMENT '是否删除：0正常1删除',
    lurl VARCHAR(160) DEFAULT NULL COMMENT '长链接',
    surl VARCHAR(11) DEFAULT NULL COMMENT '短链接',
    PRIMARY KEY (id),
    INDEX(is_del),
    UNIQUE(lurl),
    UNIQUE(surl)
) ENGINE=INNODB DEFAULT CHARSET=utf8mb4 COMMENT='长短链映射表';
```

### 数据量估算

URL网址的最大长度不同浏览器下不同。

1. 1条长链+短链的需要的存储空间假设为200Bytes/条
2. 假设每个业务线每秒会写入100条，10条业务线是1000条/秒
3. 一主两备共三份数据，索引等余系统1.5

```
200 × 1000 × 3600 × 24 × 365 × 3 × 1.5 ≈ 20T
```

## 预防攻击的方式

### 对外服务防护

- IP限制请求数
- 用户限制转链额度
- 记录已转链的URL缓存防止刷光ID（适用于相同的URL可转为不同的短链的场景）
  - LRU缓存URL
  - 布隆过滤器
- 校验链接是否有效

### 内部服务防护

- 权限认证
- 账户每日限额
- 校验链接是否有效
- 根据业务需要附加的一些打点统计信息

## 缓存相关问题

使用Redis作为缓存，需要考虑几个核心问题：

1. **缓存设置策略**
   - Redis集群部署
   - 根据数据量设置内存大小，内存淘汰策略LRU，移除最近最少使用的key

2. **解决缓存击穿问题**
   - 过期时间设大
   - 加锁
   - 使用singleflight合并请求

3. **解决缓存穿透问题**

   （大量恶意请求不存在的链接）

   - 布隆过滤器（占用空间小，如果不在那一定不在）
   - https://github.com/bits-and-blooms/bloom
   - go-zero bloom https://go-zero.dev/cn/docs/blog/governance/bloom/
   - 应用： 推荐系统去重、黑白名单

## 部署方案

单独部署、与业务隔离。

部署该项目的一种推荐方法是通过Nginx代理，即将我们的短链服务部署在Nginx后。通过这种方式，可以通过Nginx的访问日志（access.log）来统计访问数据（例如通过**EFK**采集日志，统计报表）。



* 长链转短链：
  * 单独部署为一个微服务
  * 对其他服务提供转链服务，需要鉴权。
  * 通过RESTfuIAPI调用我们的转链接口
  * 通过RPC方式调用我们的转链方法
* 查看短链接：
  * 单独部署为一个服务
  * 通过nginx转发查看请求 
  * 通过access.log收集并统计访问数据（EFK，grafama）





## 项目扩展

1. 如何支持自定义的短链?

   维护一个已经使用的序号，后续生成序号适合判断是否已经被分配

2. 如何让短链支持过期时间?

​	每个链接映射额外记录一个过期时间字段，到期后将该映射删除

* 延迟删除
* 定时删除
* 轮询删除

3. 如何提高吞吐量

   读写分离，水平扩展多节点

4. 延迟优化

* 存储层
  1. 数据结构简单可以直接改用kv存储
  2. 对存储节点继续分片
* 缓存层
  1. 增加缓存层，本地缓存 --> redis缓存
* 网络
  1. 基于地理位置选取服务器



### 架构与设计

- 问：整体架构怎么划分？为什么这么拆？

- 答：五进程：convert-rpc（转链）、show-rpc（跳转）、sequence-rpc（发号）、convert-api/show-api（HTTP 网关），前置 Nginx。拆分按职责边界解耦，发号做成独立可水平扩展的基础能力；API/业务与发号解耦，便于独立扩缩容和隔离故障面。服务发现用 Etcd，容器化部署。

- 问：为什么跳转链路先 Bloom 再 DB？

- 答：Bloom 在 Redis 上，能以 O(1) 拦截大多数不存在的短码，减少 DB 未命中负载。误判（FP）只会导致多一次 DB 查询，不影响正确性。误判率按 n=1e7, m≈20Mi bits, k≈ln2·m/n 估算在可接受范围内，可按 QPS 调整容量。

- 问：长链去重与幂等怎么做？

- 答：对 longUrl 做 md5，short_url_map.md5 唯一；重复请求直接返回已有短链（API 层幂等）。并发下依赖唯一约束，插入冲突时回查返回既有短链。

- 问：短码生成策略与冲突避免？

- 答：sequence-rpc 发号得自增 ID，Base62 编码成短码；黑名单/保留字内存 map 过滤，命中则取下一个号。DB surl 唯一保障最终无冲突。

- 问：发号器为什么用 MySQL REPLACE INTO 而不是 Redis INCR？

- 答：MySQL 自增简单稳定、持久化，不依赖额外 HA 组件；REPLACE 以唯一键 stub 触发自增。高峰期可切到 Redis INCR 或号段预取（批量租约）降低 RPC 次数。

- 问：URL 规范化如何处理？md5 会不会因微小差异导致重复短链？

- 答：规范化包含去空格、确保 scheme、按业务策略可对 host 小写、可选去除末尾/，保留 query；再 md5。md5 理论碰撞概率极低，若有顾虑可升级 sha256 存储并保留 md5 索引。

- 问：如何避免缓存击穿/击穿风暴？

- 答：读路径支持本地/Redis 只读缓存；针对热门短码用 singleflight 合并并发 miss；DB 命中后回填缓存。Bloom 先挡绝大多数 miss。

- 问：Bloom 误判或不一致如何兜底？

- 答：误判（存在判断为存在）对结果无影响；不一致（未加入 Bloom）导致 false negative 时可“Bloom miss 仍降级查 DB”，以可用性优先；写路径失败会重试并异步修正。

- 问：短域名如何拼接/判断“输入的不能是短链”？

- 答：配置 ShortDomain，返回时 fmt.Sprintf("%s/%s")；校验时需判定 Host==ShortDomain 且 Path 符合短码格式，避免把正常 URL path 误判为短链。

- 问：状态码为什么用 302 而不是 301？

- 答：默认 302（临时）便于后续改链；营销场景更安全。若做 SEO 固化，可切 301，但需提供回滚策略。

### 可靠性与一致性

- 问：并发生成同一长链的竞争如何保证只出一个短码？

- 答：md5 唯一约束 + 事务外插入；冲突回查返回既有短链。必要时对 md5 做“先查后插”的乐观重试。

- 问：跨服务失败如何处理（比如 sequence-rpc 挂了）？

- 答：API 返回明确错误码；客户端可重试。发号器建议多副本，序列保证单调不回拨即可；也可预取号段降依赖强度。

- 问：服务发现与健康？

- 答：Etcd 注册/发现；go-zero 自带健康探测与熔断重试；Nginx upstream 用容器名/Service 名访问 API。

### 性能与容量

- 问：QPS/延迟如何估算与优化？

- 答：跳转链路 P99 毫秒级（Bloom/缓存命中）；DB 命中延迟受索引与连接池影响。容量提升路径：show-rpc/convert-rpc 横向扩容、Redis 水平扩展、Bloom 容量调优、发号器号段预取。

- 问：索引与查询模式？

- 答：short_url_map(md5 UNIQUE, surl UNIQUE, is_del INDEX)；主查 surl，转链查 md5；都走 KV 型索引，单行查询。

### 安全与风控

- 问：如何防止恶意短码与滥用？

- 答：黑名单/保留字过滤；网关限流、鉴权（token/signature）；可加 URL reachability 校验（pkg/connect），域名白名单；日志审计与封禁策略。

- 问：EFK 隐私与合规？

- 答：Nginx JSON 日志字段白名单，避免记录敏感参数；ES 设置数据保留周期与索引生命周期管理（ILM）。

### 日志与可观测

- 问：为什么选 Nginx access.log 做统计而不是应用埋点？

- 答：跳转是 302，Nginx 就是真实入口，天然覆盖全面且低侵入；必要时在应用层补充业务维度埋点并入 Prometheus/Tracing。

- 问：EFK 具体怎么落地？

- 答：Nginx JSON 日志；Filebeat 采集，Ingest Pipeline 解析 short_code/geoip/ua/latency；Kibana 仪表盘（PV/UV、TopN、状态、时延）。docker-compose 一键带 es-setup 安装 pipeline。

### 容器化与配置

- 问：为什么提供两套配置文件？

- 答：源码内本地开发配置（127.0.0.1），Compose/生产用容器内主机名（mysql/redis/etcd）；避免互相污染，支持分环境覆盖。

- 问：时区问题怎么解决？

- 答：运行镜像安装 tzdata + ENV TZ=Asia/Shanghai，或用 import _ "time/tzdata"/loc=Local。我们已统一用 tzdata 方案。

### 边界与演进

- 问：md5 碰撞/变体 URL 导致重复怎么处理？

- 答：可升级 sha256；URL 规范化后再哈希；对业务允许的等价变体（末尾斜杠）做统一化。

- 问：如何支持自定义短码、有效期、统计？

- 答：自定义码需冲突检测并避开保留字；有效期可加过期字段与后台回收；统计可加计数表或异步明细写入（消息队列/ClickHouse）。

- 问：K8s 化与弹性？

- 答：提供 Deployment/Service/Ingress 清单即可迁移；HPA 按 CPU/QPS 扩缩。Etcd/Redis/MySQL 采用托管或 Stateful 模式。

- 技术亮点（可快速陈述）

  - 微服务解耦：convert/show/sequence 三个 RPC + 两个 REST 网关，前置 Nginx，Etcd 服务发现，易水平扩展与独立容灾
  - 高性能短码生成：MySQL 自增发号 + Base62，黑名单/保留字过滤，最终一致性由 `surl` 唯一约束兜底
  - 读路径极致优化：Redis Bloom 先挡不存在短码，命中再查 DB；可选只读缓存 + singleflight 合并 miss
  - 幂等与去重：`md5(longUrl)` 唯一，重复长链直接返回原短链；并发冲突由唯一索引与乐观重试消解
  - 可观测闭环：Nginx JSON access.log → Filebeat → Elasticsearch → Kibana 看板（PV/UV、TopN、状态、时延）
  - 工程化与部署：goctl 生成 API/RPC/Model；多阶段 Dockerfile；docker-compose 一键；分环境配置与自动化 ES pipeline

  ### 关键难点与解法（并发侧重点）

  - 并发去重（同一长链并发转链）
    - 难点：同时写入导致重复短码或多条映射
    - 解法：
      - 先“查 md5 → 有则返回”，避免多数写
      - 插入依赖 `md5` 唯一约束；出现冲突（Duplicate）时回查并返回已有短链（幂等成功）
      - 业务侧重试用指数退避 + 抖动，避免瞬时羊群

  - 短码唯一与黑名单冲突（并发发号）
    - 难点：多个并发拿到相同序号或候选在黑名单/已被占用
    - 解法：
      - 发号器保证单调不回拨（MySQL 自增/Redis INCR/号段租约）
      - 生成后先内存黑名单过滤，再尝试入库；以 `surl` 唯一约束做最终裁决
      - 冲突则重取下一个号（小概率分支）

  - 缓存击穿/击穿风暴（热点短码）
    - 难点：缓存过期瞬间大量请求直打 DB
    - 解法：
      - show-rpc 使用 singleflight 以短码为 key 合并并发读取
      - 缓存回填 + 随机化 TTL（避免同刻失效）
      - 穿透：Bloom 先挡；黑名单/非法形态直接拒绝

  - Bloom 误判/不一致
    - 难点：写入 Bloom 失败或误判导致可用性/准确性问题
    - 解法：
      - 读路径策略：Bloom miss 仍降级 DB 查（高可用优先）
      - 写路径失败重试与异步修正；容量和误判率按 n 调参
      - 版本化 key（如滚动更新）降低历史遗留影响

  - 发号器扩展与单点
    - 难点：sequence-rpc 成为瓶颈或故障点
    - 解法：
      - 阶段1：MySQL 自增 + REPLACE 简单稳定（单实例可撑较高并发）
      - 阶段2：Redis INCR or 号段租约（一次取 N 个预发，减少 RPC）
      - 阶段3：多机多 segment，记录已分配区间，客户端幂等重试；唯一约束兜底

  - 限流与背压
    - 难点：营销峰值/攻击导致资源枯竭
    - 解法：
      - Nginx 限流 / go-zero 限流中间件；队列化异步审计
      - 超时预算、熔断、Retries with jitter；优雅降级（拒绝一部分非关键请求）
      - 负载剪裁：参数校验前置、早失败减少耗时操作

  - 事务与一致性
    - 难点：多写路径（DB、Bloom、缓存）顺序一致性
    - 解法：
      - 以 DB 为源；写 DB 成功视为成功，Bloom/缓存为“双写-最终一致”，失败异步补偿
      - 幂等 key（md5/surl）保证补偿可安全重试

  - 热点与分布
    - 难点：热点短码/热点地域造成倾斜
    - 解法：
      - 缓存 + singleflight + 多副本读扩展
      - 连接池上限/分库分表预留；索引覆盖查询避免回表

  - 资源与连接池
    - 难点：高并发下连接耗尽/争用
    - 解法：
      - DB/Redis 连接池上限与超时策略；gRPC max concurrent streams 与 keepalive
      - 观测连接与等待时长，做容量评估

  ### 设计选择

  - 为什么 MySQL 自增而不是雪花 ID？
    - 短码需要紧凑长度，雪花 ID 转 Base62 长度更长；MySQL 自增更短、更稳定
  - 为什么用 Nginx access.log 做统计而非应用埋点？
    - 跳转为 302，Nginx 是真实入口，无侵入且覆盖面广；业务维度可在应用补充
  - 为什么默认 302？
    - 可回滚；如需 SEO 可切 301，但要有改链策略

  ### 可能的扩展题

  - 自定义短码与保留字
    - 自定义码匹配正则（A-Za-z0-9, ≤11），先查冲突与黑名单，再入库；冲突返回 AlreadyExists
  - 过期短链
    - 表加 `expire_at`，show-rpc 读取判断过期即 NotFound；定时清理/软删除；Bloom 不删除也不影响功能
  - 防刷与风控
    - 域名白名单、URL可达性校验、鉴权签名、IP/UA 限制；黑名单扩展为服务存储

  ### 性能指标
  - 跳转链路（缓存+Bloom 命中）P99 毫秒级
  - 单机 show-rpc > 万级 QPS（取决于缓存命中与连接池）可水平扩展
  - 转链链路端到端 < 数十毫秒（发号器/DB 插入主导）

  ### 重点排障清单（被问到“遇到问题怎么查”）
  - 大量 5xx：看 go-zero 日志 + gRPC status；核对下游（sequence/DB/Redis）延迟与错误
  - 3xx 异常降低：看 Nginx access，过滤 `status`，对比 `upstream_status`、`upstream_response_time`
  - 高延迟：观察连接池、慢 SQL、热 key 命中，必要时加本地缓存/提升池子

  ### 面试快答模板（并发相关）
  - “并发重复生成短链怎么解决？”
    - md5 唯一 + 先查后插 + 插入冲突回查；幂等返回；重试带抖动
  - “缓存击穿怎么扛？”
    - Bloom + 只读缓存 + singleflight；随机 TTL；热点保护
  - “发号器如何扩展？”
    - MySQL 自增 → Redis INCR → 号段预取；最终由 `surl` 唯一保证无重码
  - “一致性如何保证？”
    - DB 为准；双写（Bloom/缓存）最终一致；失败重试与异步修复；接口幂等

  需要的话，我可以把这份小抄落到 `docs/interview-cheatsheet.md`，并按你的项目名与指标做个性化微调。



