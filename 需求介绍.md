# 短链系统设计方案

## 需求背景

公司内部业务需要发送大量的营销短信、通知类短信，需要一个短链接服务满足各业务线的使用：
- 提供转链接口
- 后续支持提供点击的统计数据报表

## 需求描述

1. 输入一个长网址得到一个唯一的短网址
2. 用户点击短网址能够正常跳转到对应的网址
3. 为了保证业务的延续性，短网址长期有效

## 需求分析

### 产品定位

1. 公司内部业务使用的短网址服务，只接收公司内部的长链转短链需求（不对外提供短链功能）
2. 基本在国内使用（点击链接的用户绝大多数为国内用户）
3. 后续可能会要求提供短链的访问数据报表

### 规模

1. 大致服务于公司内部x条业务线
2. 大致服务的用户规模有x亿
3. xx QPS

### 技术指标

1. 延时xms内
2. 可靠性99.99%
3. 安全性

## 需求实现流程

需求预沟通 → 需求评审 → 技术评审 → 排期开发 → 联调 → 测试 → 上线（小流量 → 全流量）

## 需求拆解

根据需求分析，可以将需求拆分为转链模块、存储和访问链接模块。

### 转链模块

1. 相同的长链要转为同一个短链
2. 生成的短链为尽量短的字符（如：qlmi.cn/p6Yo7z）

**引申需求点或注意事项：**
1. 需要避免某些不合适的词（例如f**k、stupid）和某些特殊含义的词（version、health等）
2. 避免循环转链（把已经是短链的再拿来转短链）

### 存储

1. 保存原始长链接与短链接的对应关系
2. 能够根据短链接查找到原始的长链接

### 查看链接模块

1. 根据短链查询到长链后返回重定向响应
2. 后续数据报表需求可能需要采集并统计请求头数据

## 系统设计

### 总体设计方案

通过分析可以得知，这是一个典型的读多写少的系统。

进一步分析这个短链系统区别于其他读多写少的业务场景，它的特点是数据写入后基本不会改变（好处是不需要考虑数据一致性的问题，可以放心大胆的使用缓存系统来提高读的效率）。

### 短链生成方式

关于生成短链有以下几种方案：

#### Hash方案

使用hash函数对长链接进行hash，得到hash值作为短链标识符。

- **优势**：简单
- **缺点**：数据量大之后，会出现哈希冲突

**MurmurHash**是一种非加密型哈希函数，和其它流行哈希函数相比，对于规律性较强的key随机分布特性表现更良好，在很多开源的软件项目（Redis，Memcached，Cassandra，HBase，Lucene都用它）都有使用。有以下几个特性：
- 随机分布特性表现好
- 算法速度快

#### 发号器/自增序列方案

每收到一个转链请求，就使用发号器生成递增（1、2、3、4...以此递增）的序号，然后将该序号转为62进制，最后拼接到短域名后即得到最终的短链。

**发号器方案的优劣如下：**

- **优势**：
  - 生成的id递增
  - 理论上容量足够满足现实需求

- **缺点**：
  - 高并发下的发号器设计是难点

### 发号器实现方式

常见的发号器实现方式有以下几种：

1. **基于UUID实现**
   - 优势：不会重复、性能好
   - 劣势：数字太大了，32位16进制数

2. **基于Redis实现发号器**
   - 优势：高性能
   - 劣势：需搭建高可用架构并考虑持久化

3. **基于雪花算法的分布式ID生成器**
   - 优势：高性能、高可用
   - 劣势：实现复杂，依赖时钟

4. **基于MySQL自增主键的发号器**
   - 优势：简单、可靠
   - 劣势：依赖MySQL，性能会成为瓶颈，但可通过分片扩展可用性

### 基于MySQL主键实现发号器

这里采用的是基于MySQL数据库主键做发号器的方案。

我们新建一个数据表，这个表没有其他数据字段，只有一个主键。每有一次转链请求，我们都在这个数据库中插入一个新行，那么我们可以使用该表的自增ID作为生成的号码。

**MySQL REPLACE**

REPLACE的工作方式与INSERT完全相同，只是如果表中的旧行与新行在PRIMARY KEY或UNIQUE索引具有相同的值，则在插入新行之前删除旧行。

这就让我们能够在数据库中的单行位置进行自动更新，并获得一个新的自动递增的主ID。

### 分片部署

为了避免单点故障，我们将我们的ID生成器分成奇数和偶数两部分，分别部署在两个MySQL服务器。

两个数据表配置不同的auto-increment-offset，server1生成1、3、5、7、9...，server2生成2、4、6、8...

### 数据表

存储长-短链接映射的数据表：

```sql
CREATE TABLE short_url_map (
    id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '主键',
    create_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    create_by VARCHAR(64) NOT NULL DEFAULT '' COMMENT '创建者',
    is_del tinyint UNSIGNED NOT NULL DEFAULT '0' COMMENT '是否删除：0正常1删除',
    lurl VARCHAR(160) DEFAULT NULL COMMENT '长链接',
    surl VARCHAR(11) DEFAULT NULL COMMENT '短链接',
    PRIMARY KEY (id),
    INDEX(is_del),
    UNIQUE(lurl),
    UNIQUE(surl)
) ENGINE=INNODB DEFAULT CHARSET=utf8mb4 COMMENT='长短链映射表';
```

### 数据量估算

URL网址的最大长度不同浏览器下不同。

1. 1条长链+短链的需要的存储空间假设为200Bytes/条
2. 假设每个业务线每秒会写入100条，10条业务线是1000条/秒
3. 一主两备共三份数据，索引等余系统1.5

```
200 × 1000 × 3600 × 24 × 365 × 3 × 1.5 ≈ 20T
```

## 预防攻击的方式

### 对外服务防护

- IP限制请求数
- 用户限制转链额度
- 记录已转链的URL缓存防止刷光ID（适用于相同的URL可转为不同的短链的场景）
  - LRU缓存URL
  - 布隆过滤器
- 校验链接是否有效

### 内部服务防护

- 权限认证
- 账户每日限额
- 校验链接是否有效
- 根据业务需要附加的一些打点统计信息

## 缓存相关问题

使用Redis作为缓存，需要考虑几个核心问题：

1. **缓存设置策略**
   - Redis集群部署
   - 根据数据量设置内存大小，内存淘汰策略LRU，移除最近最少使用的key

2. **解决缓存击穿问题**
   - 过期时间设大
   - 加锁
   - 使用singleflight合并请求

3. **解决缓存穿透问题**

   （大量恶意请求不存在的链接）

   - 布隆过滤器（占用空间小，如果不在那一定不在）
   - https://github.com/bits-and-blooms/bloom
   - go-zero bloom https://go-zero.dev/cn/docs/blog/governance/bloom/
   - 应用： 推荐系统去重、黑白名单

## 部署方案

单独部署、与业务隔离。

部署该项目的一种推荐方法是通过Nginx代理，即将我们的短链服务部署在Nginx后。通过这种方式，可以通过Nginx的访问日志（access.log）来统计访问数据（例如通过**EFK**采集日志，统计报表）。



* 长链转短链：
  * 单独部署为一个微服务
  * 对其他服务提供转链服务，需要鉴权。
  * 通过RESTfuIAPI调用我们的转链接口
  * 通过RPC方式调用我们的转链方法
* 查看短链接：
  * 单独部署为一个服务
  * 通过nginx转发查看请求 
  * 通过access.log收集并统计访问数据（EFK，grafama）





## 部署
- 服务器已安装 Docker 与 Compose 插件（Docker 24+，Compose v2）。
- 防火墙放行 80、3306（可选，仅本机访问则无需放行）。

### 1. 配置检查与修改
- 编辑 `deploy/docker-compose/configs/convert.yaml`：
    - `ShortDomain` 改为你的短域名或服务器 IP（例如 `short.your.com` 或 `1.2.3.4`）。
    - 确认 `ShortUrlBlacklist` 字段名与代码一致（是 `ShortUrlBlacklist`）。
    - `ShortUrlDB.DSN` 改为你的 MySQL 密码（默认示例 `root:rootpass@tcp(mysql:3306)/url?...`）。
- 如需对外访问 API（非 Nginx 内部转发），可在 `deploy/docker-compose/docker-compose.yml` 的 `convert-api`、`show-api` 增加端口映射，例如：
    - `ports: ["8888:8888"]`、`ports: ["8889:8889"]`（可选）。

### 2. 启动依赖与服务
到项目根目录（与 `deploy` 同级）执行：
```bash
cd deploy/docker-compose
docker compose up -d --build
```
这会启动：etcd、mysql、redis、sequence-rpc、convert-rpc、show-rpc、convert-api、show-api、nginx。

### 3. 初始化数据库
首次启动需要导入表结构。
```bash
# 进入 mysql 容器
docker exec -it $(docker ps -qf "name=mysql") bash

# 在容器内执行
mysql -uroot -prootpass url < /dev/stdin <<'SQL'
$(cat /workspace/db/migrations/short_url_map.sql)
SQL

mysql -uroot -prootpass url < /dev/stdin <<'SQL'
$(cat /workspace/db/migrations/sequence.sql)
SQL
```
若容器内没有源码路径，可在宿主机执行：
```bash
docker cp ../../db/migrations/short_url_map.sql $(docker ps -qf "name=mysql"):/tmp/s1.sql
docker cp ../../db/migrations/sequence.sql $(docker ps -qf "name=mysql"):/tmp/s2.sql
docker exec -it $(docker ps -qf "name=mysql") mysql -uroot -prootpass url -e "source /tmp/s1.sql"
docker exec -it $(docker ps -qf "name=mysql") mysql -uroot -prootpass url -e "source /tmp/s2.sql"
```

### 4. 域名与 Nginx
- 若使用域名，把短域名 DNS 解析到服务器 IP。
- `nginx` 容器使用 `deploy/nginx/conf.d/shortener.conf`，已把根路径转发到 `show-api:8889`，`/convert` 转发到 `convert-api:8888`，默认监听 80。
- 如需自定义 `server_name`，编辑 `deploy/nginx/conf.d/shortener.conf` 中 `server_name` 字段，重启：
```bash
docker compose restart nginx
```

### 5. 验证
- 转链（Nginx → convert-api）：
```bash
curl -X POST "http://<你的域名或服务器IP>/convert" \
  -H "Content-Type: application/json" \
  -d "{\"longUrl\":\"https://example.com/path\"}"
```
返回形如：
```json
{"shortUrl":"<ShortDomain>/<code>"}
```
- 跳转（Nginx → show-api → 302）：
```bash
curl -I "http://<你的域名或服务器IP>/<code>"
```
应返回 `HTTP/1.1 302 Found`，`Location: https://example.com/path`

### 6. 常见问题
- 短域名未生效：确认 `convert.yaml` 的 `ShortDomain` 与你的访问域名一致。
- 连接失败：
    - `mysql` 密码或数据库名不一致，修正 DSN 并 `docker compose up -d --build`。
    - `etcd` 未连通，确认 Compose 网络下地址为 `etcd:2379`。
- 重复长链报错：当前实现对已存在长链返回错误，可按需改为直接返回已生成短链。

### 7. 日常运维
- 查看日志：
```bash
docker compose logs -f convert-api
docker compose logs -f show-api
docker compose logs -f convert-rpc
docker compose logs -f show-rpc
docker compose logs -f sequence-rpc
docker compose logs -f nginx
```
- 重启单服务：
```bash
docker compose restart convert-rpc
```
- 更新代码后重新部署：
```bash
git pull
docker compose up -d --build
```

如果你提供短域名，我可以帮你把 `ShortDomain` 和 `nginx` 的 `server_name` 对上并检查一遍配置。

