# 短链系统设计方案

## 需求背景

公司内部业务需要发送大量的营销短信、通知类短信，需要一个短链接服务满足各业务线的使用：
- 提供转链接口
- 后续支持提供点击的统计数据报表

## 需求描述

1. 输入一个长网址得到一个唯一的短网址
2. 用户点击短网址能够正常跳转到对应的网址
3. 为了保证业务的延续性，短网址长期有效

## 需求分析

### 产品定位

1. 公司内部业务使用的短网址服务，只接收公司内部的长链转短链需求（不对外提供短链功能）
2. 基本在国内使用（点击链接的用户绝大多数为国内用户）
3. 后续可能会要求提供短链的访问数据报表

### 规模

1. 大致服务于公司内部x条业务线
2. 大致服务的用户规模有x亿
3. xx QPS

### 技术指标

1. 延时xms内
2. 可靠性99.99%
3. 安全性

## 需求实现流程

需求预沟通 → 需求评审 → 技术评审 → 排期开发 → 联调 → 测试 → 上线（小流量 → 全流量）

## 需求拆解

根据需求分析，可以将需求拆分为转链模块、存储和访问链接模块。

### 转链模块

1. 相同的长链要转为同一个短链
2. 生成的短链为尽量短的字符（如：qlmi.cn/p6Yo7z）

**引申需求点或注意事项：**
1. 需要避免某些不合适的词（例如f**k、stupid）和某些特殊含义的词（version、health等）
2. 避免循环转链（把已经是短链的再拿来转短链）

### 存储

1. 保存原始长链接与短链接的对应关系
2. 能够根据短链接查找到原始的长链接

### 查看链接模块

1. 根据短链查询到长链后返回重定向响应
2. 后续数据报表需求可能需要采集并统计请求头数据

## 系统设计

### 总体设计方案

通过分析可以得知，这是一个典型的读多写少的系统。

进一步分析这个短链系统区别于其他读多写少的业务场景，它的特点是数据写入后基本不会改变（好处是不需要考虑数据一致性的问题，可以放心大胆的使用缓存系统来提高读的效率）。

### 短链生成方式

关于生成短链有以下几种方案：

#### Hash方案

使用hash函数对长链接进行hash，得到hash值作为短链标识符。

- **优势**：简单
- **缺点**：数据量大之后，会出现哈希冲突

**MurmurHash**是一种非加密型哈希函数，和其它流行哈希函数相比，对于规律性较强的key随机分布特性表现更良好，在很多开源的软件项目（Redis，Memcached，Cassandra，HBase，Lucene都用它）都有使用。有以下几个特性：
- 随机分布特性表现好
- 算法速度快

#### 发号器/自增序列方案

每收到一个转链请求，就使用发号器生成递增（1、2、3、4...以此递增）的序号，然后将该序号转为62进制，最后拼接到短域名后即得到最终的短链。

**发号器方案的优劣如下：**

- **优势**：
  - 生成的id递增
  - 理论上容量足够满足现实需求

- **缺点**：
  - 高并发下的发号器设计是难点

### 发号器实现方式

常见的发号器实现方式有以下几种：

1. **基于UUID实现**
   - 优势：不会重复、性能好
   - 劣势：数字太大了，32位16进制数

2. **基于Redis实现发号器**
   - 优势：高性能
   - 劣势：需搭建高可用架构并考虑持久化

3. **基于雪花算法的分布式ID生成器**
   - 优势：高性能、高可用
   - 劣势：实现复杂，依赖时钟

4. **基于MySQL自增主键的发号器**
   - 优势：简单、可靠
   - 劣势：依赖MySQL，性能会成为瓶颈，但可通过分片扩展可用性

### 基于MySQL主键实现发号器

这里采用的是基于MySQL数据库主键做发号器的方案。

我们新建一个数据表，这个表没有其他数据字段，只有一个主键。每有一次转链请求，我们都在这个数据库中插入一个新行，那么我们可以使用该表的自增ID作为生成的号码。

**MySQL REPLACE**

REPLACE的工作方式与INSERT完全相同，只是如果表中的旧行与新行在PRIMARY KEY或UNIQUE索引具有相同的值，则在插入新行之前删除旧行。

这就让我们能够在数据库中的单行位置进行自动更新，并获得一个新的自动递增的主ID。

### 分片部署

为了避免单点故障，我们将我们的ID生成器分成奇数和偶数两部分，分别部署在两个MySQL服务器。

两个数据表配置不同的auto-increment-offset，server1生成1、3、5、7、9...，server2生成2、4、6、8...

### 数据表

存储长-短链接映射的数据表：

```sql
CREATE TABLE short_url_map (
    id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '主键',
    create_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    create_by VARCHAR(64) NOT NULL DEFAULT '' COMMENT '创建者',
    is_del tinyint UNSIGNED NOT NULL DEFAULT '0' COMMENT '是否删除：0正常1删除',
    lurl VARCHAR(160) DEFAULT NULL COMMENT '长链接',
    surl VARCHAR(11) DEFAULT NULL COMMENT '短链接',
    PRIMARY KEY (id),
    INDEX(is_del),
    UNIQUE(lurl),
    UNIQUE(surl)
) ENGINE=INNODB DEFAULT CHARSET=utf8mb4 COMMENT='长短链映射表';
```

### 数据量估算

URL网址的最大长度不同浏览器下不同。

1. 1条长链+短链的需要的存储空间假设为200Bytes/条
2. 假设每个业务线每秒会写入100条，10条业务线是1000条/秒
3. 一主两备共三份数据，索引等余系统1.5

```
200 × 1000 × 3600 × 24 × 365 × 3 × 1.5 ≈ 20T
```

## 预防攻击的方式

### 对外服务防护

- IP限制请求数
- 用户限制转链额度
- 记录已转链的URL缓存防止刷光ID（适用于相同的URL可转为不同的短链的场景）
  - LRU缓存URL
  - 布隆过滤器
- 校验链接是否有效

### 内部服务防护

- 权限认证
- 账户每日限额
- 校验链接是否有效
- 根据业务需要附加的一些打点统计信息

## 缓存相关问题

使用Redis作为缓存，需要考虑几个核心问题：

1. **缓存设置策略**
   - Redis集群部署
   - 根据数据量设置内存大小，内存淘汰策略LRU，移除最近最少使用的key

2. **解决缓存击穿问题**
   - 过期时间设大
   - 加锁
   - 使用singleflight合并请求

3. **解决缓存穿透问题**

   （大量恶意请求不存在的链接）

   - 布隆过滤器（占用空间小，如果不在那一定不在）
   - https://github.com/bits-and-blooms/bloom
   - go-zero bloom https://go-zero.dev/cn/docs/blog/governance/bloom/
   - 应用： 推荐系统去重、黑白名单

## 部署方案

单独部署、与业务隔离。

部署该项目的一种推荐方法是通过Nginx代理，即将我们的短链服务部署在Nginx后。通过这种方式，可以通过Nginx的访问日志（access.log）来统计访问数据（例如通过**EFK**采集日志，统计报表）。



* 长链转短链：
  * 单独部署为一个微服务
  * 对其他服务提供转链服务，需要鉴权。
  * 通过RESTfuIAPI调用我们的转链接口
  * 通过RPC方式调用我们的转链方法
* 查看短链接：
  * 单独部署为一个服务
  * 通过nginx转发查看请求 
  * 通过access.log收集并统计访问数据（EFK，grafama）







